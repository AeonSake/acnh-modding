<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no, viewport-fit=cover">
  <link rel="shortcut icon" type="image/x-icon" href="acnh-modding/favicon.ico">
  <!-- Replace with your own title and description. -->
  <title>ACNH Modding Docs</title>
  <meta name="description"
    content="A docs containing all information you need to know about Animal Crossing: New Horizons modding">

  <!-- Default Theme (see https://docsify.js.org/#/themes) -->
  <!--  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css"> -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple-dark.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>

<body>
  <div id="app"></div>

  <script src="//cdn.jsdelivr.net/npm/docsify-edit-on-github"></script>

  <script>
    // Docsify Configuration (see https://docsify.js.org/#/configuration)
    window.$docsify = {
      name: 'ACNH Modding',

      // Sidebar Configuration
      auto2top: true,
      loadSidebar: true,
      maxLevel: 0,
      // Set subMaxLevel to 0 to remove automatic display of page table of contents (TOC) in Sidebar
      subMaxLevel: 2,

      // Search Plugin Configuration
      search: {
        placeholder: 'Type to search',
        noData: 'No matches found.',
        // Headline depth, 1 - 6
        depth: 2,
      },

      plugins: [
        EditOnGithubPlugin.create("https://github.com/Rafacasari/acnh-modding/blob/main/")
      ]


    };
  </script>

  <!-- Required -->
  <script src="https://cdn.jsdelivr.net/npm/docsify@4/lib/docsify.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/docsify-pagination/dist/docsify-pagination.min.js"></script>

  <!-- Reccomended -->
  <script src="https://cdn.jsdelivr.net/npm/docsify@4/lib/plugins/zoom-image.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docsify@4/lib/plugins/search.js"></script>

  <script>
    // Wait page to load
    window.addEventListener('load', function () {
      function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      const generateButton = document.getElementById("generateButton");
      const npcLabel = document.getElementById("npcLabel");
      const npcName = document.getElementById("npcName");

      // let randomNumber;
      // let randomNumberingId;

      function getCurrentDate() {
        const date = new Date();
        return {
          y: date.getFullYear(),
          m: date.getMonth() + 1,
          d: date.getDate()
        };
      }

      function generateRandomUUID() {
        return (Array.from({ length: 8 }, () => Math.floor(Math.random() * 256))).concat([0, 0, 0]);
      }

      function NoSpecialChars(e) { 
        var regex = new RegExp("^[a-zA-Z0-9]+$");
        var str = String.fromCharCode(!e.charCode ? e.which : e.charCode);
        if (regex.test(str)) {
          return true;
        }

        e.preventDefault();
        return false;
      }

      npcLabel.addEventListener('onkeypress', NoSpecialChars);


      generateButton.addEventListener("click", () => {
        if (npcName.value == "" || npcLabel.value == "") return;

        // Last original entry + 256 
        let characterId = getRandomInt(663552 + 256, 4294967295);
        characterId = Math.abs(characterId & -256); // Make sure our value is positive

        let numberingId = getRandomInt(984, 65535);

        console.log("Generated CharacterId: " + characterId);
        console.log("Generated numberingId: " + numberingId);

        SaveBCSVFile(characterId, numberingId);
        SaveAmiiboZip(characterId, numberingId);
      });


      function SaveBCSVFile(characterId, numberingId) {
        if (npcLabel.value == "") return;

        const blobParts = [];
        const entrySize = 28; // AmiiboData EntrySize

        const fields = [
          { "Hash": 3350015967, "Offset": 4 }, 
          { "Hash": 77885493, "Offset": 8 }, 
          { "Hash": 4138945558, "Offset": 10 }, 
          { "Hash": 2890543941, "Offset": 12 }, 
          { "Hash": 885583573, "Offset": 13 }, 
          { "Hash": 2175024758, "Offset": 21 }, 
          { "Hash": 3701969225, "Offset": 22 }, 
          { "Hash": 1534894258, "Offset": 23 }, 
          { "Hash": 496616723, "Offset": 24 }, 
          { "Hash": 196503666, "Offset": 25 }
        ];

        // Header
        blobParts.push(new Uint32Array([1]));  // Entries Count
        blobParts.push(new Uint32Array([entrySize])); // Entry Size
        blobParts.push(new Uint16Array([fields.length])); // Field Count
        blobParts.push(new Uint8Array([1])); // HasExtenderHeader
        blobParts.push(new Uint8Array([1])); // Unknown
        blobParts.push(new TextEncoder().encode("VSCB")); // BCSV magic
        blobParts.push(new Uint16Array([20100])); // Version
        blobParts.push(new Uint8Array(10)); // Padding

        // Write Fields
        fields.forEach(field => {
          blobParts.push(new Uint32Array([field["Hash"]]));
          blobParts.push(new Uint32Array([field["Offset"]]));
        });

        // Writing our entry (in this case only one)
        const entryPosition = new Uint32Array([blobParts.reduce((acc, curr) => acc + curr.byteLength, 0)]);
        blobParts.push(entryPosition);

        blobParts.push(new Uint32Array([characterId])); // Random Id
        blobParts.push(new Int16Array([numberingId])); // Numbering Id
        blobParts.push(new Uint16Array([-1]));
        blobParts.push(new Uint8Array([1]));

        let textData = [0, 0, 0, 0, 0, 0, 0, 0]
        let newText = new TextEncoder().encode(npcLabel.value);

        for (let i = 0; i < newText.length; i++) {
          if (i >= 8) return;
          textData[i] = newText[i];
        }

        blobParts.push(new Uint8Array(textData));

        blobParts.push(new Uint8Array([0]));
        blobParts.push(new Uint8Array([0]));
        blobParts.push(new Uint8Array([5]));
        blobParts.push(new Uint8Array([0]));

        blobParts.push(new Uint8Array([0]));
        blobParts.push(new Uint8Array([0]));
        blobParts.push(new Uint8Array([0]));


        const blob = new Blob(blobParts, { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "AmiiboData_" + npcLabel.value + ".bcsv";
        a.click();
        URL.revokeObjectURL(url);
      }


      function resize(arr, newSize, defaultValue) {
        return [...arr, ...Array(Math.max(newSize - arr.length, 0)).fill(defaultValue)];
      }

      function toAmiiboId(value) {
        value = value >> 4;
        let firstDigit = (value >> 12) & 0xF;
        let shiftedValue = (value & 0xFFF) << 4;
        return shiftedValue | firstDigit;
      }

      function SaveAmiiboZip(characterId, numberingId) {
        const zip = new JSZip();

        const amiibo_data = {
          name: npcName.value,
          write_counter: 0,
          version: 0,
          mii_charinfo_file: 'mii-charinfo.bin',
          first_write_date: getCurrentDate(),
          last_write_date: getCurrentDate(),
          id: {
            game_character_id: toAmiiboId(characterId),
            character_variant: 0,
            figure_type: 1,
            series: 5,
            model_number: numberingId
          },
          use_random_uuid: true,
          uuid: generateRandomUUID()
        };


        const jsonString = JSON.stringify(amiibo_data, null, 2);
        zip.file("amiibo.json", jsonString);
        zip.file("amiibo.flag", new Uint8Array());
        zip.file("amiibo.png", new Uint8Array());

        zip.generateAsync({ type: "blob" }).then(function (content) {
          const a = document.createElement("a");
          const url = URL.createObjectURL(content);
          a.href = url;
          a.download = "amiibo.zip";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url); // Libera a memÃ³ria do Blob
        });
      }
    });
  </script>

</body>

</html>